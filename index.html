<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Moldes para Costura v2.0</title>
    <style>
        :root {
            --primary-color: #2c6e49; /* Verde escuro */
            --secondary-color: #4c956c; /* Verde médio */
            --light-bg: #fefee3; /* Amarelo bem claro / Creme */
            --text-color: #333;
            --border-color: #ddd;
            --page-bg: #ffffff;
            --piece-bg: rgba(76, 149, 108, 0.1);
            --piece-border: #4c956c;
        }

        /* --- ESTILOS GERAIS --- */
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1600px;
            margin: auto;
        }
        .controls {
            flex: 1;
            min-width: 350px;
            max-width: 500px;
            background: var(--page-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            height: fit-content;
        }
        .preview-area {
            flex: 3;
            min-width: 300px;
        }
        h1, h2 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
            margin-top: 0;
        }
        h1 { font-size: 1.8em; }
        h2 { font-size: 1.4em; }

        /* --- ESTILOS DOS CONTROLES --- */
        #bulk-input {
            width: 100%;
            height: 250px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        label {
            font-weight: bold;
            display: block;
            margin-bottom: 8px;
            color: var(--primary-color);
        }
        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            width: 100%;
            margin-top: 10px;
            transition: background-color 0.3s;
            font-weight: bold;
        }
        button:hover {
            background-color: var(--primary-color);
        }
        .print-button {
            background-color: var(--primary-color);
        }
        .print-button:hover {
            background-color: #1e4c32;
        }

        /* --- ESTILOS DA VISUALIZAÇÃO --- */
        #canvas-container {
            background: #e9e9e9;
            padding: 20px;
            border-radius: 8px;
        }
        .page {
            background: var(--page-bg);
            width: 21cm;
            height: 29.7cm;
            position: relative;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
            margin: 0 auto 20px auto;
            overflow: hidden;
            page-break-after: always;
        }
        .page-footer {
            position: absolute;
            bottom: 1cm;
            left: 1cm;
            right: 1cm;
            text-align: center;
            font-size: 10px;
            color: #aaa;
        }

        /* --- ESTILOS SVG --- */
        .piece-svg {
            position: absolute;
            overflow: visible;
        }
        .piece-shape {
            fill: var(--piece-bg);
            stroke: var(--piece-border);
            stroke-width: 1;
        }
        .helper-line {
            stroke: var(--piece-border);
            stroke-width: 1;
            stroke-dasharray: 4 2;
            opacity: 0.7;
        }
        .piece-text {
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            fill: var(--primary-color);
            text-anchor: middle;
        }
        .piece-text-name {
            font-weight: bold;
            font-size: 14px;
        }
        .join-line {
            stroke: #d9534f;
            stroke-width: 2;
            stroke-dasharray: 5 3;
        }
        .join-text {
            font-size: 11px;
            fill: #d9534f;
            font-weight: bold;
            text-anchor: middle;
        }

        /* --- ESTILOS DE IMPRESSÃO --- */
        @media print {
            body { background-color: #fff; padding: 0; margin: 0; }
            .controls, .preview-area h1, .preview-area h2 { display: none; }
            .container { display: block; }
            #canvas-container { padding: 0; background: none; }
            .page { box-shadow: none; margin: 0; border-radius: 0; }
        }
    </style>
</head>
<body>

    <div class="container">
        <aside class="controls">
            <h1>Gerador de Moldes 2.0</h1>
            <label for="bulk-input">Insira as medidas (Nome, Largura x Altura, Raio, Qtde):</label>
            <textarea id="bulk-input">Corpo Atrás, 26x15, 3, 1x Tecido 3x Forro
Corpo Frente (Baixo), 26x13, 3, 1x Tecido 1x Forro
Corpo Frente (Cima), 26x9, 3, 1x Tecido 1x Forro
Fundo, 42x14, 0, 1x Tecido 1x Forro
Faixa Zíper, 42x7, 0, 2x Tecido 2x Forro
Faixa Vivo, 82x4, 0, 2x Tecido
EVA Estrutura 1, 22x11, 3, 1x EVA
EVA Estrutura 2, 38x10, 0, 1x EVA
EVA Estrutura 3, 38x3, 0, 2x EVA
Bolso Tela 1, 26x12, 0, 1x Tela
Bolso Tela 2, 26x3, 0, 1x Tela
Bolso Tela 3, 26x12, 0, 1x Tela</textarea>
            <button onclick="generateLayout()">Gerar Moldes</button>
            <button onclick="window.print()" class="print-button">Salvar como PDF / Imprimir</button>
        </aside>

        <main class="preview-area">
            <h1>Visualização para Impressão</h1>
            <div id="canvas-container">
                <!-- Páginas serão geradas aqui -->
            </div>
        </main>
    </div>

    <script>
        const DPI = 96;
        const CM_PER_INCH = 2.54;
        const PX_PER_CM = DPI / CM_PER_INCH;

        const PAGE_WIDTH_CM = 21;
        const PAGE_HEIGHT_CM = 29.7;
        const MARGIN_CM = 1;

        const AVAILABLE_WIDTH_CM = PAGE_WIDTH_CM - (MARGIN_CM * 2);
        const AVAILABLE_HEIGHT_CM = PAGE_HEIGHT_CM - (MARGIN_CM * 2);

        function parseBulkInput() {
            const input = document.getElementById('bulk-input').value;
            const lines = input.split('\n').filter(line => line.trim() !== '');
            return lines.map(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length < 4) return null;
                const [name, dimensions, radius, qty] = parts;
                const [w, h] = dimensions.toLowerCase().split('x').map(Number);
                const r = Number(radius);
                return { name, w, h, r, qty };
            }).filter(p => p && !isNaN(p.w) && !isNaN(p.h));
        }

        function createNewPage(pageNumber) {
            const page = document.createElement('div');
            page.className = 'page';
            page.innerHTML = `<div class="page-footer">Página ${pageNumber} - Gerado por Manus AI</div>`;
            return page;
        }

        function generateLayout() {
            const pieces = parseBulkInput();
            const container = document.getElementById('canvas-container');
            container.innerHTML = '';

            let pages = [];
            let currentPositions = []; // { x, y } for each page

            const addPage = () => {
                const newPage = createNewPage(pages.length + 1);
                container.appendChild(newPage);
                pages.push(newPage);
                currentPositions.push({ x: MARGIN_CM, y: MARGIN_CM });
            };

            addPage();

            pieces.forEach(piece => {
                placePiece(piece, pages, currentPositions, addPage);
            });
        }

        function placePiece(piece, pages, positions, addPage) {
            // Check if piece is too large and needs splitting
            if (piece.w > AVAILABLE_WIDTH_CM) {
                splitAndPlacePiece(piece, pages, positions, addPage);
                return;
            }

            // Try to fit the piece (normal and rotated)
            let w = piece.w;
            let h = piece.h;
            let rotated = false;

            if (piece.h > piece.w && piece.h <= AVAILABLE_WIDTH_CM) {
                 [w, h] = [h, w];
                 rotated = true;
            }

            let placed = false;
            for (let i = 0; i < pages.length; i++) {
                if (positions[i].x + w <= AVAILABLE_WIDTH_CM && positions[i].y + h <= AVAILABLE_HEIGHT_CM) {
                    drawPiece(pages[i], piece, positions[i].x, positions[i].y, rotated);
                    positions[i].x += w + MARGIN_CM;
                    placed = true;
                    break;
                } else if (positions[i].y + h <= AVAILABLE_HEIGHT_CM) {
                    positions[i].x = MARGIN_CM;
                    positions[i].y += findMaxHeightOnRow(pages[i], positions[i].y) + MARGIN_CM;
                     if (positions[i].y + h <= AVAILABLE_HEIGHT_CM) {
                        drawPiece(pages[i], piece, positions[i].x, positions[i].y, rotated);
                        positions[i].x += w + MARGIN_CM;
                        placed = true;
                        break;
                    }
                }
            }

            if (!placed) {
                addPage();
                const lastIndex = pages.length - 1;
                drawPiece(pages[lastIndex], piece, positions[lastIndex].x, positions[lastIndex].y, rotated);
                positions[lastIndex].x += w + MARGIN_CM;
            }
        }
        
        function findMaxHeightOnRow(page, y_cm) {
            // Helper to find the tallest element starting at a certain Y to align the next row
            // This is a simplified packing algorithm. For this tool, we'll just use a fixed gap.
            // A more complex implementation would be needed for true bin packing.
            // For now, we assume pieces are placed and the next row starts after the tallest one.
            // This logic is simplified in the main loop.
            return 0; // Simplified
        }

        function splitAndPlacePiece(piece, pages, positions, addPage) {
            let remainingWidth = piece.w;
            let part = 1;
            let xOffset = 0;

            while (remainingWidth > 0) {
                addPage();
                const pageIndex = pages.length - 1;
                const page = pages[pageIndex];
                
                const widthForThisPart = Math.min(remainingWidth, AVAILABLE_WIDTH_CM);
                
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                const w_px = widthForThisPart * PX_PER_CM;
                const h_px = piece.h * PX_PER_CM;
                
                svg.setAttribute('class', 'piece-svg');
                svg.setAttribute('width', w_px);
                svg.setAttribute('height', h_px);
                svg.style.left = `${MARGIN_CM * PX_PER_CM}px`;
                svg.style.top = `${MARGIN_CM * PX_PER_CM}px`;

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute('class', 'piece-shape');
                path.setAttribute('d', `M0,0 H${w_px} V${h_px} H0 Z`);
                svg.appendChild(path);

                // Add join lines and text
                if (part > 1) { // Line on the left
                    svg.innerHTML += `<line class="join-line" x1="1" y1="0" x2="1" y2="${h_px}" />
                                     <text class="join-text" x="20" y="${h_px/2}" transform="rotate(-90, 20, ${h_px/2})">Unir com Parte ${part-1}</text>`;
                }
                if (remainingWidth - widthForThisPart > 0) { // Line on the right
                    svg.innerHTML += `<line class="join-line" x1="${w_px-1}" y1="0" x2="${w_px-1}" y2="${h_px}" />
                                     <text class="join-text" x="${w_px-20}" y="${h_px/2}" transform="rotate(90, ${w_px-20}, ${h_px/2})">Unir com Parte ${part+1}</text>`;
                }

                // Add text
                const text = `<text class="piece-text" x="${w_px/2}" y="${h_px/2}">
                                <tspan class="piece-text-name" x="${w_px/2}" dy="-1.2em">${piece.name} (Parte ${part})</tspan>
                                <tspan x="${w_px/2}" dy="1.2em">${widthForThisPart.toFixed(1)}cm x ${piece.h.toFixed(1)}cm</tspan>
                                <tspan x="${w_px/2}" dy="1.2em">${piece.qty}</tspan>
                              </text>`;
                svg.innerHTML += text;

                page.appendChild(svg);
                
                remainingWidth -= widthForThisPart;
                xOffset += widthForThisPart;
                part++;
            }
        }

        function drawPiece(page, pieceData, x_cm, y_cm, rotated) {
            const { name, r, qty } = pieceData;
            let w = rotated ? pieceData.h : pieceData.w;
            let h = rotated ? pieceData.w : pieceData.h;

            const w_px = w * PX_PER_CM;
            const h_px = h * PX_PER_CM;
            const r_px = r * PX_PER_CM;

            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute('class', 'piece-svg');
            svg.setAttribute('width', w_px);
            svg.setAttribute('height', h_px);
            svg.style.left = `${x_cm * PX_PER_CM}px`;
            svg.style.top = `${y_cm * PX_PER_CM}px`;

            // Create SVG path for the shape with rounded corners
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute('class', 'piece-shape');
            
            // A=arc command: rx ry x-axis-rotation large-arc-flag sweep-flag x y
            const d = `M${r_px},0 
                       L${w_px - r_px},0 
                       A${r_px},${r_px} 0 0 1 ${w_px},${r_px} 
                       L${w_px},${h_px - r_px} 
                       A${r_px},${r_px} 0 0 1 ${w_px - r_px},${h_px} 
                       L${r_px},${h_px} 
                       A${r_px},${r_px} 0 0 1 0,${h_px - r_px} 
                       L0,${r_px} 
                       A${r_px},${r_px} 0 0 1 ${r_px},0 Z`;
            path.setAttribute('d', d);
            svg.appendChild(path);

            // Add helper lines for radius
            if (r > 0) {
                svg.innerHTML += `<line class="helper-line" x1="${r_px}" y1="0" x2="${r_px}" y2="${r_px}" />`;
                svg.innerHTML += `<line class="helper-line" x1="0" y1="${r_px}" x2="${r_px}" y2="${r_px}" />`;
                // Add for other corners as needed...
            }

            // Add text content
            const text = `<text class="piece-text" x="${w_px/2}" y="${h_px/2}">
                            <tspan class="piece-text-name" x="${w_px/2}" dy="-1.2em">${name}</tspan>
                            <tspan x="${w_px/2}" dy="1.2em">${pieceData.w.toFixed(1)}cm x ${pieceData.h.toFixed(1)}cm</tspan>
                            <tspan x="${w_px/2}" dy="1.2em">${qty}</tspan>
                          </text>`;
            svg.innerHTML += text;

            page.appendChild(svg);
        }

        window.onload = generateLayout;
    </script>
</body>
</html>
